#!/usr/bin/env node
/**
 * Generates bundled .d.ts strings for react-tela modules and writes them
 * as importable TypeScript constants for the Monaco playground editor.
 *
 * Usage: node scripts/generate-playground-types.mjs
 */

import { execFileSync } from 'node:child_process';
import { readFileSync, writeFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = resolve(__dirname, '..');

const entries = [
  { entry: 'src/index.tsx', module: 'react-tela' },
  { entry: 'src/render.ts', module: 'react-tela/render' },
  { entry: 'src/flex.tsx', module: 'react-tela/flex' },
];

const results = {};

for (const { entry, module: moduleName } of entries) {
  const tmpFile = join(tmpdir(), `react-tela-${moduleName.replace(/\//g, '-')}.d.ts`);

  execFileSync(
    resolve(root, 'node_modules/.bin/dts-bundle-generator'),
    ['-o', tmpFile, '--no-check', resolve(root, entry)],
    { cwd: root, stdio: ['pipe', 'pipe', 'pipe'] },
  );

  let content = readFileSync(tmpFile, 'utf-8');

  // Strip the "Generated by" comment
  content = content.replace(/^\/\/ Generated by dts-bundle-generator.*\n\n?/, '');

  // Convert to a `declare module` block for Monaco.
  // 1. Remove top-level `import` statements (React etc.) — Monaco has its own React stub
  // 2. Remove `export {};` at the end
  // 3. Strip `export` from declarations (they're implicitly exported inside declare module)
  //    Actually keep `export` — it's valid inside declare module blocks.
  // 4. Replace `React$1` references with `React` (artifact of dts-bundle-generator)
  content = content
    .replace(/^import .*;\n/gm, '')
    .replace(/\nexport \{\};?\s*$/, '')
    .replace(/React\$1/g, 'React');

  // Remove internal class declarations that conflict with exported React component
  // consts (e.g. `declare class Text$1` vs `declare const Text$1`). TypeScript's JSX
  // resolution would pick the class constructor signature over the function type,
  // causing false type errors.
  content = stripConflictingClasses(content);

  content = content.trim();

  // Wrap in declare module
  const wrapped = `declare module "${moduleName}" {\n  import React from "react";\n  import { PropsWithChildren, ReactNode } from "react";\n${indent(content)}\n}`;

  results[moduleName] = wrapped;
}

/**
 * Remove `declare class Foo` blocks when a `declare const Foo` also exists.
 * dts-bundle-generator emits both the internal class (e.g. Text$1 with
 * constructor(opts: TextProps)) and the React component wrapper (e.g.
 * const Text$1: ForwardRefExoticComponent<...>). The class confuses
 * TypeScript's JSX resolution because it picks the class constructor
 * props (which may require different fields) over the function type.
 */
function stripConflictingClasses(content) {
  const lines = content.split('\n');

  // Collect names that have both a class and a const declaration
  const classNames = new Set();
  const constNames = new Set();
  for (const line of lines) {
    const cm = line.match(/^(?:export\s+)?declare\s+class\s+(\w+)/);
    if (cm) classNames.add(cm[1]);
    const vm = line.match(/^(?:export\s+)?declare\s+const\s+(\w+)/);
    if (vm) constNames.add(vm[1]);
  }
  const conflicts = new Set([...classNames].filter((n) => constNames.has(n)));
  if (conflicts.size === 0) return content;

  // Remove class blocks for conflicting names
  const result = [];
  let skip = 0;
  for (const line of lines) {
    if (skip > 0) {
      // Track brace depth to find end of class block
      for (const ch of line) {
        if (ch === '{') skip++;
        else if (ch === '}') skip--;
      }
      continue;
    }
    const cm = line.match(/^(?:export\s+)?declare\s+(?:abstract\s+)?class\s+(\w+)/);
    if (cm && conflicts.has(cm[1])) {
      // Start skipping this class block
      for (const ch of line) {
        if (ch === '{') skip++;
        else if (ch === '}') skip--;
      }
      continue;
    }
    result.push(line);
  }
  return result.join('\n');
}

function indent(text) {
  return text
    .split('\n')
    .map((line) => (line ? `  ${line}` : line))
    .join('\n');
}

function varName(mod) {
  return (
    mod
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .trim()
      .split(' ')
      .map((w, i) =>
        i === 0
          ? w.toLowerCase()
          : w[0].toUpperCase() + w.slice(1).toLowerCase(),
      )
      .join('') + 'Types'
  );
}

// Build output file
const output = `// AUTO-GENERATED — do not edit manually.
// Run \`pnpm generate:types\` to regenerate from source.

${Object.entries(results)
  .map(([mod, dts]) => `export const ${varName(mod)} = ${JSON.stringify(dts)};`)
  .join('\n\n')}
`;

const outPath = resolve(root, 'playground/src/generated-types.ts');
writeFileSync(outPath, output);
console.log(`✅ Generated ${outPath}`);
